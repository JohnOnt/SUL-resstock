# see the URL below for information on how to write OpenStudio measures
# http://nrel.github.io/OpenStudio-user-documentation/measures/measure_writing_guide/

require 'csv'

# start the measure
class RebuildExistingModel < OpenStudio::Ruleset::ModelUserScript

  # human readable name
  def name
    return "Rebuild Existing Model"
  end

  # human readable description
  def description
    return "Rebuilds the OpenStudio Model for an existing building."
  end

  # human readable description of modeling approach
  def modeler_description
    return "Rebuilds the OpenStudio Model using the analysis results csv file generated from an existing housing stock run."
  end

  # define the arguments that the user will input
  def arguments(model)
    args = OpenStudio::Ruleset::OSArgumentVector.new

    # FIXME: Temporarily changed to integer
    sample_value = OpenStudio::Ruleset::OSArgument.makeIntegerArgument("sample_value", true)
    sample_value.setDisplayName("Sample Value")
    sample_value.setDescription("The sample value determined by the OpenStudio sampling algorithm.")
    args << sample_value
    
    return args
  end

  # define what happens when the measure is run
  def run(model, runner, user_arguments)
    super(model, runner, user_arguments)

    # use the built-in error checking
    if !runner.validateUserArguments(arguments(model), user_arguments)
      return false
    end
    
    # FIXME: Temporarily changed to integer
    sample_value = runner.getIntegerArgumentValue("sample_value",user_arguments)
    
    # Get file/dir paths
    resources_dir = File.absolute_path(File.join(File.dirname(__FILE__), "..", "..", "lib", "resources")) # Should have been uploaded per 'Other Library Files' in analysis spreadsheet
    helper_methods_file = File.join(resources_dir, "helper_methods.rb")
    measures_dir = File.join(resources_dir, "measures")
    lookup_file = File.join(resources_dir, "options_lookup.tsv")
    resstock_csv = File.absolute_path(File.join(File.dirname(__FILE__), "..", "..", "lib", "existing_results", "resstock.csv")) # Should have been uploaded per 'Other Library Files' in analysis spreadsheet
    resstock_metadata_csv = File.absolute_path(File.join(File.dirname(__FILE__), "..", "..", "lib", "existing_results", "resstock_metadata.csv")) # Should have been uploaded per 'Other Library Files' in analysis spreadsheet
    resstock_order_csv = File.absolute_path(File.join(File.dirname(__FILE__), "..", "..", "lib", "existing_results", "resstock_order.csv")) # Should have been uploaded per 'Other Library Files' in analysis spreadsheet
    
    # Load helper_methods
    require File.join(File.dirname(helper_methods_file), File.basename(helper_methods_file, File.extname(helper_methods_file)))

    # Check file/dir paths exist
    check_dir_exists(measures_dir, runner)
    check_file_exists(lookup_file, runner)
    check_file_exists(resstock_csv, runner)
    check_file_exists(resstock_metadata_csv, runner)

    # Convert sample value to a sample number
    # FIXME: Temporarily disabled
    #total_samples = runner.analysis[:analysis][:problem][:algorithm][:number_of_samples].to_f
    #sample_number = [(sample_value * total_samples).ceil, 1].max
    #runner.registerInfo("Sample value #{sample_value.to_s} converted to sample number #{sample_number.to_s}.")
    sample_number = sample_value
    
    # Retrieve all data associated with sample number
    datapoint_prefix = "LHS Autogenerated "
    bldg_data = get_data_for_sample(resstock_csv, sample_number, datapoint_prefix, runner)
    register_value(runner, "Existing Datapoint Name", "#{datapoint_prefix}#{sample_number.to_s}")
    
    # Retrieve order of parameters to run
    parameters_ordered = get_parameters_ordered(resstock_order_csv)

    # Call each measure for sample to build up model
    key_prefix = "res_stock_reporting."
    parameters_ordered.each do |parameter_name|
        # Get measure name and arguments associated with the option name
        option_name = bldg_data[key_prefix + parameter_name]
        measure_args = get_measure_args_from_option_name(lookup_file, option_name, parameter_name, runner)
        
        measure_args.keys.each do |measure_subdir|
            # Gather measure arguments and call measure
            full_measure_path = File.join(measures_dir, measure_subdir, "measure.rb")
            check_file_exists(full_measure_path, runner)
            
            measure = get_measure_instance(full_measure_path)
            argument_map = get_argument_map(model, measure, measure_args[measure_subdir], lookup_file, parameter_name, option_name, runner)
            print_info(measure_args[measure_subdir], measure_subdir, option_name, runner)

            if not run_measure(model, measure, argument_map, runner)
                return false
            end
        end
        
        if measure_args.empty?
            print_info(nil, nil, option_name, runner)
        end
        
        #Uncomment this to have the parameters of the existing home in the output csv file
        #The outputs will also need to be added to the analysis spreadsheet outputs tab.
        #register_value(runner, parameter_name, option_name)
    end
    
    return true

  end
  
  def get_data_for_sample(resstock_csv, sample_number, datapoint_prefix, runner)
    CSV.foreach(resstock_csv, headers:true) do |sample|
        next if sample['name'].sub(datapoint_prefix,"").to_i != sample_number
        return sample
    end
    # If we got this far, couldn't find the sample #
    msg = "Could not find row for #{sample_number.to_s} in #{File.basename(resstock_csv).to_s}."
    runner.registerError(msg)
    fail msg
  end
  
  def get_parameters_ordered(resstock_order_csv)
    return CSV.open(resstock_order_csv, 'r') { |csv| csv.first }
  end
  
end

# register the measure to be used by the application
RebuildExistingModel.new.registerWithApplication
